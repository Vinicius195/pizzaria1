# Firebase Studio

This is a NextJS starter in Firebase Studio.

To get started, take a look at src/app/page.tsx.

## Supabase Schema Setup

To use this application, you need to configure your Supabase project. Follow these steps in your Supabase dashboard.

### 1. Enable Row Level Security (RLS)

Before running any SQL, ensure that Row Level Security is enabled for all tables you will create. You can usually find this setting in your project's authentication or API settings.

### 2. Run the SQL Setup Script

Go to the **SQL Editor** in your Supabase dashboard and run the following script. This single script will create all the necessary tables, functions, and triggers for the application to function correctly.

```sql
-- Profiles table to store public user data
CREATE TABLE public.profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  updated_at timestamp with time zone,
  name text,
  email text,
  role text,
  status text,
  avatar text,
  fallback text,
  PRIMARY KEY (id)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Public profiles are viewable by authenticated users." ON public.profiles FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
CREATE POLICY "Admins can update any profile." ON public.profiles FOR UPDATE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador');
CREATE POLICY "Admins can delete profiles." ON public.profiles FOR DELETE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador') AND (auth.uid() <> id));

-- Products table
CREATE TABLE public.products (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  name text NOT NULL,
  category text NOT NULL,
  sizes jsonb,
  price numeric,
  "isAvailable" boolean NOT NULL DEFAULT true,
  description text,
  PRIMARY KEY (id)
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Products are viewable by authenticated users." ON public.products FOR SELECT TO authenticated USING (true);
CREATE POLICY "Admins can manage products." ON public.products FOR ALL TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador')) WITH CHECK (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador'));

-- Customers table
CREATE TABLE public.customers (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  name text NOT NULL,
  phone text,
  address text,
  "locationLink" text,
  "lastOrderDate" date,
  "totalSpent" numeric NOT NULL DEFAULT 0,
  "orderCount" integer NOT NULL DEFAULT 0,
  PRIMARY KEY (id)
);
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT TO authenticated USING (true);
CREATE POLICY "Admins and employees can manage customers." ON public.customers FOR ALL TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Administrador', 'Funcionário'))) WITH CHECK (((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Administrador', 'Funcionário')));

-- Orders table
CREATE TABLE public.orders (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  "customerName" text NOT NULL,
  "customerPhone" text,
  items jsonb NOT NULL,
  total numeric NOT NULL,
  status text NOT NULL,
  timestamp text NOT NULL,
  "orderType" text NOT NULL,
  address text,
  "locationLink" text,
  notes text
);
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Orders are viewable by authenticated users." ON public.orders FOR SELECT TO authenticated USING (true);
CREATE POLICY "Authenticated users can create orders." ON public.orders FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Users can update orders." ON public.orders FOR UPDATE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Administrador', 'Funcionário')));
CREATE POLICY "Admins can delete orders." ON public.orders FOR DELETE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador'));

-- Notifications table
CREATE TABLE public.notifications (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    title text NOT NULL,
    description text NOT NULL,
    "isRead" boolean NOT NULL DEFAULT false,
    "targetRoles" jsonb NOT NULL,
    link text,
    PRIMARY KEY (id)
);
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own notifications." ON public.notifications FOR SELECT TO authenticated USING ("targetRoles" @> to_jsonb((SELECT role FROM public.profiles WHERE id = auth.uid())::text));
CREATE POLICY "Authenticated users can create notifications." ON public.notifications FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Users can update notifications to mark as read." ON public.notifications FOR UPDATE TO authenticated USING ("targetRoles" @> to_jsonb((SELECT role FROM public.profiles WHERE id = auth.uid())::text));

-- Settings table (singleton, only one row)
CREATE TABLE public.settings (
  id int8 PRIMARY KEY,
  "basePrices" jsonb,
  "sizeAvailability" jsonb
);
ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Settings are viewable by authenticated users" ON public.settings FOR SELECT TO authenticated USING (true);
CREATE POLICY "Admins can update settings" ON public.settings FOR UPDATE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador')) WITH CHECK (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador'));

-- Insert the single row of settings
INSERT INTO public.settings (id, "basePrices", "sizeAvailability")
VALUES (
  1,
  '{"GG": 65, "medio": 45, "grande": 55, "pequeno": 35}',
  '{"GG": true, "medio": true, "grande": true, "pequeno": true}'
);

-- Function to create a new profile when a user signs up.
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, name, email, role, status, fallback)
  values (
    new.id,
    new.raw_user_meta_data->>'name',
    new.email,
    new.raw_user_meta_data->>'role',
    'Pendente',
    SUBSTRING(new.raw_user_meta_data->>'name' FROM 1 FOR 1)
  );
  return new;
end;
$$;

-- Trigger to run the function when a new user is created.
create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- Function to create a notification for a new user
create or replace function public.create_new_user_notification()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.notifications (title, description, "targetRoles", link)
  values (
    'Novo Usuário Registrado',
    'O usuário ' || new.name || ' (' || new.email || ') se registrou como ' || new.role || ' e precisa de aprovação.',
    '["Administrador"]'::jsonb,
    '/configuracoes'
  );
  return new;
end;
$$;

-- Trigger to run the notification function when a new profile is created
create or replace trigger on_profile_created
  after insert on public.profiles
  for each row execute procedure public.create_new_user_notification();

```

### 3. (Optional but Recommended) Disable Email Confirmation

For the registration flow to be as smooth as possible, it is recommended to disable the "Confirm email" feature in your Supabase project.

1.  Go to **Authentication** -> **Providers**.
2.  Find the **Email** provider and click the three dots to select **Edit**.
3.  Turn **OFF** the toggle for "Confirm email".
4.  Click **Save**.


After these steps, your Supabase backend will be fully configured to work with the application.
