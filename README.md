# Firebase Studio

This is a NextJS starter in Firebase Studio.

To get started, take a look at src/app/page.tsx.

## Supabase Schema Setup

To use this application, you need to configure your Supabase project. Follow these steps in your Supabase dashboard.

### 1. Enable Row Level Security (RLS)

Before running any SQL, ensure that Row Level Security is enabled for all tables you will create. You can usually find this setting in your project's authentication or API settings.

### 2. Run the SQL Schema Script

Go to the **SQL Editor** in your Supabase dashboard and run the following script. This will create all the necessary tables and policies for the application to function correctly.

```sql
-- Profiles table to store public user data
CREATE TABLE public.profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  updated_at timestamp with time zone,
  name text,
  email text,
  role text,
  status text,
  avatar text,
  fallback text,
  PRIMARY KEY (id)
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
-- Policies for profiles:
CREATE POLICY "Public profiles are viewable by authenticated users." ON public.profiles FOR SELECT TO authenticated USING (true);
CREATE POLICY "Users can update own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
CREATE POLICY "Admins can update any profile." ON public.profiles FOR UPDATE TO authenticated USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador');
CREATE POLICY "Admins can delete profiles." ON public.profiles FOR DELETE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador') AND (auth.uid() <> id));

-- Products table
CREATE TABLE public.products (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  name text NOT NULL,
  category text NOT NULL,
  sizes jsonb,
  price numeric,
  "isAvailable" boolean NOT NULL DEFAULT true,
  description text,
  PRIMARY KEY (id)
);
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Products are viewable by authenticated users." ON public.products FOR SELECT TO authenticated USING (true);
CREATE POLICY "Admins can manage products." ON public.products FOR ALL TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador')) WITH CHECK (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador'));

-- Customers table
CREATE TABLE public.customers (
  id uuid NOT NULL DEFAULT gen_random_uuid(),
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  name text NOT NULL,
  phone text,
  address text,
  "locationLink" text,
  "lastOrderDate" date,
  "totalSpent" numeric NOT NULL DEFAULT 0,
  "orderCount" integer NOT NULL DEFAULT 0,
  PRIMARY KEY (id)
);
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Customers are viewable by authenticated users." ON public.customers FOR SELECT TO authenticated USING (true);
CREATE POLICY "Admins and employees can manage customers." ON public.customers FOR ALL TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Administrador', 'Funcionário'))) WITH CHECK (((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Administrador', 'Funcionário')));


-- Orders table
CREATE TABLE public.orders (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  "customerName" text NOT NULL,
  "customerPhone" text,
  items jsonb NOT NULL,
  total numeric NOT NULL,
  status text NOT NULL,
  timestamp text NOT NULL,
  "orderType" text NOT NULL,
  address text,
  "locationLink" text,
  notes text
);
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Orders are viewable by authenticated users." ON public.orders FOR SELECT TO authenticated USING (true);
CREATE POLICY "Authenticated users can create orders." ON public.orders FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Users can update orders." ON public.orders FOR UPDATE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('Administrador', 'Funcionário')));
CREATE POLICY "Admins can delete orders." ON public.orders FOR DELETE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador'));


-- Notifications table
CREATE TABLE public.notifications (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    title text NOT NULL,
    description text NOT NULL,
    "isRead" boolean NOT NULL DEFAULT false,
    "targetRoles" jsonb NOT NULL,
    link text,
    PRIMARY KEY (id)
);
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users can view their own notifications." ON public.notifications FOR SELECT TO authenticated USING ("targetRoles" @> to_jsonb((SELECT role FROM public.profiles WHERE id = auth.uid())::text));
CREATE POLICY "Authenticated users can create notifications." ON public.notifications FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Users can update notifications to mark as read." ON public.notifications FOR UPDATE TO authenticated USING ("targetRoles" @> to_jsonb((SELECT role FROM public.profiles WHERE id = auth.uid())::text));

-- Settings table (singleton, only one row)
CREATE TABLE public.settings (
  id int8 PRIMARY KEY,
  "basePrices" jsonb,
  "sizeAvailability" jsonb
);
ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Settings are viewable by authenticated users" ON public.settings FOR SELECT TO authenticated USING (true);
CREATE POLICY "Admins can update settings" ON public.settings FOR UPDATE TO authenticated USING (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador')) WITH CHECK (((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'Administrador'));

-- Insert the single row of settings
INSERT INTO public.settings (id, "basePrices", "sizeAvailability")
VALUES (
  1,
  '{"GG": 65, "medio": 45, "grande": 55, "pequeno": 35}',
  '{"GG": true, "medio": true, "grande": true, "pequeno": true}'
);
```

### 3. Create the User Profile Sync Function and Trigger

This function automatically creates a profile for a new user upon registration.

Go to **Database** > **Functions** and create a new function called `handle_new_user`. Use the code below for its definition.
```sql
-- Function to create a new profile when a user signs up.
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, name, email, role, status, fallback)
  values (
    new.id,
    new.raw_user_meta_data->>'name',
    new.email,
    new.raw_user_meta_data->>'role',
    'Pendente',
    SUBSTRING(new.raw_user_meta_data->>'name' FROM 1 FOR 1)
  );
  return new;
end;
$$;
```
> **Note**: When creating via the UI, set the "Return type" to `trigger` and "Language" to `plpgsql`. The "Behavior" can be left as the default `VOLATILE`. The function body goes in the "Definition" field. Under "Advanced Settings", set "Security" to `DEFINER`.

Now, create a trigger to execute the function. Go to **Database** > **Triggers** and create a new trigger with the following settings:
- **Name**: `on_auth_user_created`
- **Table**: `users` (in the `auth` schema). **Important:** You will need to switch from the `public` schema to the `auth` schema in the table selector dropdown to find the `users` table.
- **Events**: `INSERT`
- **Trigger Type**: `After`
- **Function**: `handle_new_user`

### 4. Create the New User Notification Function and Trigger

This function will automatically create a notification for administrators whenever a new user's profile is created.

First, create the function. Go to **Database** > **Functions** and create a new function called `create_new_user_notification`.
```sql
-- Function to create a notification for a new user
create function public.create_new_user_notification()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.notifications (title, description, "targetRoles", link)
  values (
    'Novo Usuário Registrado',
    'O usuário ' || new.name || ' (' || new.email || ') se registrou como ' || new.role || ' e precisa de aprovação.',
    '["Administrador"]'::jsonb,
    '/configuracoes'
  );
  return new;
end;
$$;
```
> **Note**: Just like before, set the "Return type" to `trigger`, "Language" to `plpgsql`, "Behavior" to `VOLATILE` (default), and "Security" to `DEFINER`.

Next, create the trigger. Go to **Database** > **Triggers** and create a new trigger with these settings:
- **Name**: `on_profile_created`
- **Table**: `profiles` (in the `public` schema)
- **Events**: `INSERT`
- **Trigger Type**: `After`
- **Function**: `create_new_user_notification`

### 5. (Optional but Recommended) Disable Email Confirmation

For the registration flow to be as smooth as possible, it is recommended to disable the "Confirm email" feature in your Supabase project.

1.  Go to **Authentication** -> **Providers**.
2.  Find the **Email** provider and click the three dots to select **Edit**.
3.  Turn **OFF** the toggle for "Confirm email".
4.  Click **Save**.


After these steps, your Supabase backend will be fully configured to work with the application.
